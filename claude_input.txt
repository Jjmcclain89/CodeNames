================================================================================
COMBINED FILES FOR CLAUDE IMPORT
Generated from 1 files
================================================================================

TABLE OF CONTENTS:
 1. backend/src/socket/socketHandlers.ts

================================================================================

============================================================
FILE: backend/src/socket/socketHandlers.ts
PATH: C:\Users\Jmccl\Coding Projects\CodeNames\backend\src\socket\socketHandlers.ts
SIZE: 18782 characters
============================================================
import { Server, Socket } from 'socket.io';
import { PrismaClient } from '@prisma/client';
import jwt from 'jsonwebtoken';
import { gameService } from '../services/gameService';
import { TeamColor, PlayerRole } from '../../../shared/types/game';
import { gameLobbies } from '../routes/gameLobbies';

interface AuthenticatedSocket extends Socket {
  userId?: string;
  username?: string;
  currentRoom?: string;
}

export const handleSocketConnection = (io: Server, socket: AuthenticatedSocket, prisma: PrismaClient) => {
  console.log('ğŸš€ Socket connection handler starting for:', socket.id);
  
  // Global error handler for this socket
  socket.on('error', (error) => {
    console.error('ğŸš¨ Socket error:', error);
  });
  
  // Wrap all handler registration in try-catch
  try {
    console.log('ğŸ”§ Starting handler registration...');
  console.log(`ğŸ“¡ Socket connected: ${socket.id}`);

  // Authentication (keeping simple version for now)
  socket.on('authenticate', async (token: string) => {
    console.log(`ğŸ” Authenticating socket: ${socket.id}`);
    
    // âœ… Consistent user ID that matches game players
    socket.userId = `user_${socket.id}`;
    socket.username = `Player_${socket.id.substring(0, 4)}`;
    socket.currentRoom = 'GLOBAL';
    
    // Store userId on the socket object for frontend access
    (socket as any).userId = socket.userId;
    
    socket.join('GLOBAL');
    
    socket.emit('authenticated', { 
      success: true, 
      userId: socket.userId,
      username: socket.username 
    });
    
    console.log(`âœ… Socket ${socket.id} authenticated as ${socket.username} with ID ${socket.userId}`);
  });

  // Auth bypass for testing
  socket.on('auth-bypass', (username: string) => {
    console.log('ğŸ”“ Auth bypass requested');
    socket.userId = `user_${socket.id}`;
    socket.username = username || `Player_${socket.id.substring(0, 4)}`;
    socket.currentRoom = 'GLOBAL';
    socket.join('GLOBAL');
    
    socket.emit('authenticated', { 
      success: true, 
      userId: socket.userId,
      username: socket.username 
    });
    
    console.log(`âœ… Auth bypass successful for ${socket.username}`);
  });

  // Test connection
  socket.on('test-connection', () => {
    console.log('ğŸ§ª Test connection from:', socket.username || 'unauthenticated');
    socket.emit('test-response', { 
  
  // ğŸ§ª SUPER SIMPLE TEST HANDLER
  socket.on('SIMPLE_TEST', () => {
    console.log('ğŸ¯ğŸ¯ğŸ¯ SIMPLE TEST EVENT RECEIVED! ğŸ¯ğŸ¯ğŸ¯');
  });
  
  
  // ğŸ§ª HANDLER REGISTRATION DEBUG
  console.log('ğŸ”§ About to register lobby:leave-team handler...');
  console.log('ğŸ”§ Socket object exists:', !!socket);
  console.log('ğŸ”§ Socket.on function exists:', typeof socket.on);
  
  try {
    console.log('ğŸ”§ Registering lobby:leave-team...');
    socket.on('lobby:leave-team', (data) => {
    console.log('ğŸ¯ğŸ¯ğŸ¯ LOBBY LEAVE TEAM EVENT RECEIVED! ğŸ¯ğŸ¯ğŸ¯');
    console.log('Data:', data);
  });
      message: 'Backend is working!', 
      username: socket.username,
      authenticated: !!socket.userId
    });
  });

  // âœ… PROPER GAME MANAGEMENT - Using gameService

  // Create or join game
  socket.on('game:create', () => {
    if (!socket.userId) {
      socket.emit('game:error', 'Not authenticated');
      return;
    }

    console.log(`ğŸ® Creating/joining game for ${socket.username}`);
    
    // Create or get existing game for room GLOBAL
    let game = gameService.getGameForRoom('GLOBAL');
    if (!game) {
      game = gameService.createGameForRoom('GLOBAL');
    }

    // Add player to game
    const success = gameService.addPlayerToGame(game.getId(), socket.userId, socket.username!, socket.id);
    
    if (success) {
      const gameState = game.getGame();
      io.to('GLOBAL').emit('game:state-updated', gameState);
      console.log(`âœ… ${socket.username} joined game ${game.getId()}`);
    } else {
      socket.emit('game:error', 'Failed to join game');
    }
  });

  // Add test players
  socket.on('game:add-test-players', () => {
    if (!socket.userId) {
      socket.emit('game:error', 'Not authenticated');
      return;
    }

    console.log('ğŸ¤– Adding test players...');
    
    const game = gameService.getGameByPlayer(socket.userId);
    if (!game) {
      socket.emit('game:error', 'No game found');
      return;
    }

    // Add test players
    const testPlayers = [
      { id: 'test_red_spy', username: 'ğŸ”´ Red Spy (AI)', team: 'red' as TeamColor, role: 'spymaster' as PlayerRole },
      { id: 'test_red_op', username: 'ğŸ”´ Red Op (AI)', team: 'red' as TeamColor, role: 'operative' as PlayerRole },
      { id: 'test_blue_spy', username: 'ğŸ”µ Blue Spy (AI)', team: 'blue' as TeamColor, role: 'spymaster' as PlayerRole }
    ];

    testPlayers.forEach(testPlayer => {
      game.addPlayer(testPlayer.id, testPlayer.username, 'test-socket');
      game.assignPlayerToTeam(testPlayer.id, testPlayer.team, testPlayer.role);
    });

    const gameState = game.getGame();
    io.to('GLOBAL').emit('game:state-updated', gameState);
    socket.emit('game:test-players-added', { message: 'Test players added!', playersAdded: 3 });
    
    console.log(`âœ… Added ${testPlayers.length} test players`);
  });

  // Join team
  socket.on('game:join-team', (team: TeamColor, role: PlayerRole) => {
    if (!socket.userId) {
      socket.emit('game:error', 'Not authenticated');
      return;
    }

    console.log(`ğŸ‘¥ ${socket.username} joining ${team} team as ${role}`);

    const result = gameService.assignPlayerToTeam(socket.userId, team, role);
    
    if (result.success) {
      const game = gameService.getGameByPlayer(socket.userId);
      if (game) {
        const gameState = game.getGame();
        io.to('GLOBAL').emit('game:state-updated', gameState);
        console.log(`âœ… ${socket.username} joined ${team} team as ${role}`);
      }
    } else {
      socket.emit('game:error', result.error || 'Failed to join team');
    }
  });

  // Start game
  socket.on('game:start', () => {
    if (!socket.userId) {
      socket.emit('game:error', 'Not authenticated');
      return;
    }

    console.log(`ğŸš€ Starting game...`);
    
    const result = gameService.startGame(socket.userId);
    
    if (result.success) {
      const game = gameService.getGameByPlayer(socket.userId);
      if (game) {
        const gameState = game.getGame();
        io.to('GLOBAL').emit('game:state-updated', gameState);
        console.log(`âœ… Game started successfully`);
      }
    } else {
      socket.emit('game:error', result.error || 'Failed to start game');
    }
  });

  // âœ… PROPER GAMEPLAY ACTIONS

  // Give clue
  socket.on('game:give-clue', (clueData: { word: string; number: number }) => {
    if (!socket.userId) {
      socket.emit('game:error', 'Not authenticated');
      return;
    }

    console.log(`ğŸ’¡ ${socket.username} giving clue: ${clueData.word} (${clueData.number})`);

    const result = gameService.giveClue(socket.userId, clueData.word, clueData.number);
    
    if (result.success) {
      const game = gameService.getGameByPlayer(socket.userId);
      if (game) {
        const gameState = game.getGame();
        io.to('GLOBAL').emit('game:state-updated', gameState);
        io.to('GLOBAL').emit('game:clue-given', gameState.currentClue);
        console.log(`âœ… Clue given: ${clueData.word} (${clueData.number})`);
      }
    } else {
      socket.emit('game:error', result.error || 'Failed to give clue');
    }
  });

  // Reveal card
  socket.on('game:reveal-card', (cardId: string) => {
    if (!socket.userId) {
      socket.emit('game:error', 'Not authenticated');
      return;
    }

    console.log(`ğŸ¯ ${socket.username} revealing card: ${cardId}`);

    const result = gameService.revealCard(socket.userId, cardId);
    
    if (result.success) {
      const game = gameService.getGameByPlayer(socket.userId);
      if (game) {
        const gameState = game.getGame();
        io.to('GLOBAL').emit('game:state-updated', gameState);
        io.to('GLOBAL').emit('game:card-revealed', result.card);
        
        if (result.gameEnded && result.winner) {
          io.to('GLOBAL').emit('game:game-ended', result.winner);
          console.log(`ğŸ† Game ended! Winner: ${result.winner}`);
        } else {
          console.log(`âœ… Card revealed: ${result.card?.word} (${result.card?.team})`);
        }
      }
    } else {
      socket.emit('game:error', result.error || 'Failed to reveal card');
    }
  });

  // End turn
  socket.on('game:end-turn', () => {
    if (!socket.userId) {
      socket.emit('game:error', 'Not authenticated');
      return;
    }

    console.log(`â­ï¸ ${socket.username} ending turn`);

    const result = gameService.endTurn(socket.userId);
    
    if (result.success) {
      const game = gameService.getGameByPlayer(socket.userId);
      if (game) {
        const gameState = game.getGame();
        io.to('GLOBAL').emit('game:state-updated', gameState);
        io.to('GLOBAL').emit('game:turn-changed', gameState.currentTurn);
        console.log(`âœ… Turn ended, now ${gameState.currentTurn} team's turn`);
      }
    } else {
      socket.emit('game:error', result.error || 'Failed to end turn');
    }
  });

  // âœ… LOBBY MANAGEMENT HANDLERS

  // Join lobby
  socket.on('join-lobby', (lobbyCode: string) => {
    if (!socket.userId) {
      socket.emit('lobby-error', 'Not authenticated');
      return;
    }

    console.log(`ğŸšª ${socket.username} joining lobby: ${lobbyCode}`);
    
    const lobby = gameLobbies.get(lobbyCode);
    if (!lobby) {
      socket.emit('lobby-error', 'Lobby not found');
      return;
    }

    // Join the socket room for this lobby
    socket.join(lobbyCode);
    socket.currentRoom = lobbyCode;

    // Emit lobby state to the joining player
    socket.emit('lobby-updated', lobby);
    
    console.log(`âœ… ${socket.username} joined lobby ${lobbyCode}`);
  });

  // Join team in lobby
  socket.on('lobby:join-team', (data: { lobbyId: string; team: string; role: string }) => {
    if (!socket.userId) {
      socket.emit('lobby-error', 'Not authenticated');
      return;
    }

    const { lobbyId, team, role } = data;
    console.log(`ğŸ‘¥ ${socket.username} joining ${team} team as ${role} in lobby ${lobbyId}`);

    const lobby = gameLobbies.get(lobbyId);
    if (!lobby) {
      socket.emit('lobby-error', 'Lobby not found');
      return;
    }

    // Create player object
    const player = {
      id: socket.userId,
      username: socket.username!,
      isOnline: true,
      socketId: socket.id
    };

    // Add to appropriate team
    if (team === 'red') {
      if (!lobby.redTeam) {
        lobby.redTeam = { spymaster: undefined, operatives: [] };
      }
      
      if (role === 'spymaster') {
        lobby.redTeam.spymaster = player;
      } else {
        // Remove from operatives first if already there
        lobby.redTeam.operatives = lobby.redTeam.operatives.filter(p => p.id !== socket.userId);
        lobby.redTeam.operatives.push(player);
      }
    } else if (team === 'blue') {
      if (!lobby.blueTeam) {
        lobby.blueTeam = { spymaster: undefined, operatives: [] };
      }
      
      if (role === 'spymaster') {
        lobby.blueTeam.spymaster = player;
      } else {
        // Remove from operatives first if already there
        lobby.blueTeam.operatives = lobby.blueTeam.operatives.filter(p => p.id !== socket.userId);
        lobby.blueTeam.operatives.push(player);
      }
    }

    // Remove player from other team if they were there
    if (team === 'red' && lobby.blueTeam) {
      if (lobby.blueTeam.spymaster?.id === socket.userId) {
        lobby.blueTeam.spymaster = undefined;
      }
      lobby.blueTeam.operatives = lobby.blueTeam.operatives.filter(p => p.id !== socket.userId);
    } else if (team === 'blue' && lobby.redTeam) {
      if (lobby.redTeam.spymaster?.id === socket.userId) {
        lobby.redTeam.spymaster = undefined;
      }
      lobby.redTeam.operatives = lobby.redTeam.operatives.filter(p => p.id !== socket.userId);
    }

    lobby.updatedAt = new Date().toISOString();

    // Broadcast updated lobby state to all players in the lobby
    io.to(lobbyId).emit('lobby-updated', lobby);
    
    console.log(`âœ… ${socket.username} joined ${team} team as ${role}`);
  });

  // Leave team in lobby - WITH DETAILED DEBUGGING
  socket.on('lobby:leave-team', (data: { lobbyId: string; team: string; role: string }) => {
    console.log('ğŸŸ¡ LEAVE TEAM EVENT RECEIVED!', data);
    
    if (!socket.userId) {
      socket.emit('lobby-error', 'Not authenticated');
      return;
    }

    const { lobbyId, team, role } = data;
    const lobby = gameLobbies.get(lobbyId);
    
    if (!lobby) {
      socket.emit('lobby-error', 'Lobby not found');
      return;
    }

    let removed = false;

    // Remove from red team
    if (team === 'red' && lobby.redTeam) {
      if (role === 'spymaster' && lobby.redTeam.spymaster?.id === socket.userId) {
        lobby.redTeam.spymaster = undefined;
        removed = true;
      } else if (role === 'operative') {
        const originalLength = lobby.redTeam.operatives.length;
        lobby.redTeam.operatives = lobby.redTeam.operatives.filter(p => p.id !== socket.userId);
        removed = lobby.redTeam.operatives.length < originalLength;
      }
    }
    
    // Remove from blue team
    if (team === 'blue' && lobby.blueTeam) {
      if (role === 'spymaster' && lobby.blueTeam.spymaster?.id === socket.userId) {
        lobby.blueTeam.spymaster = undefined;
        removed = true;
      } else if (role === 'operative') {
        const originalLength = lobby.blueTeam.operatives.length;
        lobby.blueTeam.operatives = lobby.blueTeam.operatives.filter(p => p.id !== socket.userId);
        removed = lobby.blueTeam.operatives.length < originalLength;
      }
    }

    if (removed) {
      lobby.updatedAt = new Date().toISOString();
      io.to(lobbyId).emit('lobby-updated', lobby);
      console.log(`âœ… ${socket.username} left ${team} team as ${role}`);
    } else {
      console.log(`âŒ Failed to remove ${socket.username} from ${team} team`);
    }
  });

  
    console.log('âœ… lobby:leave-team handler registered successfully!');
  } catch (error) {
    console.error('âŒ ERROR registering lobby:leave-team handler:', error);
    console.error('âŒ Error details:', error.message);
    console.error('âŒ Stack trace:', error.stack);
  }

  socket.on('lobby:start-game', (data: { lobbyId: string }) => {
    if (!socket.userId) {
      socket.emit('lobby-error', 'Not authenticated');
      return;
    }

    const { lobbyId } = data;
    console.log(`ğŸš€ ${socket.username} attempting to start game in lobby ${lobbyId}`);

    const lobby = gameLobbies.get(lobbyId);
    if (!lobby) {
      socket.emit('lobby-error', 'Lobby not found');
      return;
    }

    // âœ… OWNERSHIP VALIDATION - Only lobby owner can start the game
    if (lobby.owner !== socket.userId) {
      console.log(`âŒ ${socket.username} (${socket.userId}) tried to start game but is not owner (${lobby.owner})`);
      socket.emit('lobby-error', 'Only the lobby owner can start the game');
      return;
    }

    // Validate teams
    const redTeamValid = lobby.redTeam && 
                        lobby.redTeam.spymaster && 
                        lobby.redTeam.operatives.length > 0;
                        
    const blueTeamValid = lobby.blueTeam && 
                         lobby.blueTeam.spymaster && 
                         lobby.blueTeam.operatives.length > 0;

    if (!redTeamValid && !blueTeamValid) {
      socket.emit('lobby-error', 'Need at least one valid team (spymaster + operatives) to start');
      return;
    }

    // Create game from lobby
    console.log(`ğŸ® Creating game from lobby ${lobbyId}...`);
    
    try {
      // Create game using existing game service
      const game = gameService.createGameForRoom(lobbyId);
      
      // Transfer players from lobby to game
      if (lobby.redTeam?.spymaster) {
        game.addPlayer(lobby.redTeam.spymaster.id, lobby.redTeam.spymaster.username, lobby.redTeam.spymaster.socketId || '');
        game.assignPlayerToTeam(lobby.redTeam.spymaster.id, 'red', 'spymaster');
      }
      if (lobby.redTeam?.operatives) {
        lobby.redTeam.operatives.forEach(player => {
          game.addPlayer(player.id, player.username, player.socketId || '');
          game.assignPlayerToTeam(player.id, 'red', 'operative');
        });
      }
      if (lobby.blueTeam?.spymaster) {
        game.addPlayer(lobby.blueTeam.spymaster.id, lobby.blueTeam.spymaster.username, lobby.blueTeam.spymaster.socketId || '');
        game.assignPlayerToTeam(lobby.blueTeam.spymaster.id, 'blue', 'spymaster');
      }
      if (lobby.blueTeam?.operatives) {
        lobby.blueTeam.operatives.forEach(player => {
          game.addPlayer(player.id, player.username, player.socketId || '');
          game.assignPlayerToTeam(player.id, 'blue', 'operative');
        });
      }

      // Start the game
      const startResult = game.startGame();
      if (!startResult) {
        socket.emit('lobby-error', 'Failed to start game');
        return;
      }

      // Update lobby status
      lobby.status = 'playing';
      lobby.updatedAt = new Date().toISOString();

      // Notify all players in the lobby to redirect to the game
      io.to(lobbyId).emit('game-started', { 
        redirectTo: `/game/${lobbyId}`,
        gameId: lobbyId 
      });
      
      console.log(`âœ… Game started successfully for lobby ${lobbyId}`);
      
    } catch (error) {
      console.error(`âŒ Error starting game for lobby ${lobbyId}:`, error);
      socket.emit('lobby-error', 'Failed to start game: ' + (error instanceof Error ? error.message : 'Unknown error'));
    }
  });

  // Handle disconnection
  socket.on('disconnect', () => {
    console.log('ğŸ“¡ Socket disconnected: ' + socket.id);
    
    if (socket.userId) {
      // Update player offline status but don't remove them
      gameService.updatePlayerOnlineStatus(socket.userId, false);
      
      const game = gameService.getGameByPlayer(socket.userId);
      if (game) {
        const gameState = game.getGame();
        io.to('GLOBAL').emit('game:state-updated', gameState);
      }
    }
  });

    // ğŸ” LIST ALL REGISTERED HANDLERS
    console.log('ğŸ” Listing all registered socket handlers...');
    const allEvents = socket.eventNames();
    console.log('ğŸ” Registered events:', allEvents);
    console.log('ğŸ” Total events registered:', allEvents.length);
    console.log('ğŸ” lobby:leave-team registered?', allEvents.includes('lobby:leave-team'));
    
        console.log('âœ… All handlers registered successfully');
  } catch (globalError) {
    console.error('ğŸš¨ GLOBAL ERROR in handler registration:', globalError);
    console.error('ğŸš¨ This prevented some handlers from being registered!');
  }
};


================================================================================
END OF COMBINED FILES
================================================================================
